# Операторы

Sanny Builder поддерживает запись многих стандартных операций без опкодов. Компилятор анализирует обе стороны выражения и оператор между ними, чтобы подобрать правильный опкод.

В связи с особенностями языка, разные типы данных требуют разных опкодов. Например, в операции сложения двух целых чисел используется опкод, отличный от аналогичной операции с дробными числами. В некоторых случаях это требует предварительного [объявления типа](variables.md#declaring-a-variable-type) переменных, участвующих в выражении.

Большинство поддерживаемых операций в Sanny Builder используют лишь два операнда: один слева от оператора (**LHS**), и один - справа (**RHS**).

### Присваивание

* `LHS = RHS` - операция присваивания. `RHS` - число, переменная или строка. В присваивании `LHS` всегда является переменной.
* `LHS += RHS` - операция сложения с присваиванием. `LHS` и `RHS` должны быть одного типа, целого или дробного. Значение `LHS` увеличивается на соответствующее значение `RHS`.
* `LHS -= RHS` - операция вычитания с присваиванием
* `LHS *= RHS` - операция умножения с присваиванием
* `LHS /= RHS` - операция деления с присваиванием

Нижеперечисленные операции требуют [расширения](../edit-modes/extensions.md) CLEO (`{$USE CLEO}` или `{$CLEO}`).

* `LHS = value1 + value2` - сложить два целых числа и записать результат в `LHS`
* `LHS = value1 - value2` - вычесть одно целое число из другого и записать результат в `LHS`
* `LHS = value1 * value2` - перемножить два целых числа и записать результат в `LHS`
* `LHS = value1 / value2` - разделить одно целое число на другое и записать результат в `LHS`

### Сравнение

* `LHS == RHS` - операция "равно". Стороны должны иметь одинаковое значение, чтобы результат был истиной (true).
* `LHS > RHS` - операция "больше чем"
* `LHS >= RHS` - операция "больше либо равно"
* `LHS < RHS` - операция "меньше чем"
* `LHS <= RHS` - операция "меньше либо равно"
* `LHS <> RHS` - операция "не равно". Стороны должны иметь разные значения, чтобы результат был истиной (true).

{% hint style="info" %}
В языке нет отдельного типа Boolean. Результат каждого сравнения имеет значение только в пределах текущего [условного выражения](conditions.md).
{% endhint %}

### Побитовые операции

Игра не поддерживает побитовые операции, поэтому для их использования нужен особый [плагин CLEO](https://library.sannybuilder.com/#/sa/bitwise). Кроме того, в исходном коде при помощи директивы `{$USE bitwise}` должно быть подключено соответствующее [расширение](../edit-modes/extensions.md).

| Операция                      | Опкод | Пример        |
| ----------------------------- | ----- | ------------- |
| AND                           | 0B10  | 0@ = 1@ & 2@  |
| OR                            | 0B11  | 0@ = 1@ \| 2@ |
| XOR                           | 0B12  | 0@ = 1@ ^ 2@  |
| NOT                           | 0B13  | 0@ = \~1@     |
| MOD                           | 0B14  | 0@ = 1@ % 2@  |
| Shift Right                   | 0B15  | 0@ = 1@ >> 2@ |
| Shift Left                    | 0B16  | 0@ = 1@ << 2@ |
| AND (с  присваиванием)        | 0B17  | 0@ &= 1@      |
| OR (с присваиванием)          | 0B18  | 0@ \|= 1@     |
| XOR (с присваиванием)         | 0B19  | 0@ ^= 1@      |
| NOT (унарный)                 | 0B1A  | \~0@          |
| MOD (с присваиванием)         | 0B1B  | 0@ %= 1@      |
| Shift Right (с присваиванием) | 0B1C  | 0@ >>= 1@     |
| Shift Left (с присваиванием)  | 0B1D  | 0@ <<= 1@     |

### FPS-независимое сложение и вычитание

Игра поддерживает операции сложения и вычитания, которые не зависят от FPS. Прочитайте [статью](https://gtamods.com/wiki/SCM\_language#Operators) на GTAMods.com чтобы узнать больше.

| Команда                                    | Опкод | Пример          |
| ------------------------------------------ | ----- | --------------- |
| ADD\_TIMED\_VAL\_TO\_FLOAT\_VAR            | 0078  | $var +=@ 5.0    |
| ADD\_TIMED\_VAL\_TO\_FLOAT\_LVAR           | 0079  | 0@ +=@ 5.0      |
| ADD\_TIMED\_FLOAT\_VAR\_TO\_FLOAT\_VAR     | 007A  | $var1 +=@ $var2 |
| ADD\_TIMED\_FLOAT\_LVAR\_TO\_FLOAT\_LVAR   | 007B  | 0@ +=@ 1@       |
| ADD\_TIMED\_FLOAT\_VAR\_TO\_FLOAT\_LVAR    | 007C  | 0@ +=@ $var     |
| ADD\_TIMED\_FLOAT\_LVAR\_TO\_FLOAT\_VAR    | 007D  | $var +=@ 1@     |
| SUB\_TIMED\_VAL\_FROM\_FLOAT\_VAR          | 007E  | $var -=@ 5.0    |
| SUB\_TIMED\_VAL\_FROM\_FLOAT\_LVAR         | 007F  | 0@ -=@ 5.0      |
| SUB\_TIMED\_FLOAT\_VAR\_FROM\_FLOAT\_VAR   | 0080  | $var1 -=@ $var2 |
| SUB\_TIMED\_FLOAT\_LVAR\_FROM\_FLOAT\_LVAR | 0081  | 0@ -=@ 1@       |
| SUB\_TIMED\_FLOAT\_VAR\_FROM\_FLOAT\_LVAR  | 0082  | 0@ -=@ $var     |
| SUB\_TIMED\_FLOAT\_LVAR\_FROM\_FLOAT\_VAR  | 0083  | $var -=@ 1@     |

### Конвертация типов

Некоторые значения могут быть сконвертированы в другой тип. Игра поддерживает перевод между типами `Integer` и `Float`.

| Команда                          | Опкод | Пример   |
| -------------------------------- | ----- | -------- |
| CSET\_VAR\_INT\_TO\_VAR\_FLOAT   | 008C  | $i =# $f |
| CSET\_VAR\_FLOAT\_TO\_VAR\_INT   | 008D  | $f =# $i |
| CSET\_LVAR\_INT\_TO\_VAR\_FLOAT  | 008E  | 0@ =# $f |
| CSET\_LVAR\_FLOAT\_TO\_VAR\_INT  | 008F  | 1@ =# $i |
| CSET\_VAR\_INT\_TO\_LVAR\_FLOAT  | 0090  | $i =# 1@ |
| CSET\_VAR\_FLOAT\_TO\_LVAR\_INT  | 0091  | $f =# 0@ |
| CSET\_LVAR\_INT\_TO\_LVAR\_FLOAT | 0092  | 0@ =# 1@ |
| CSET\_LVAR\_FLOAT\_TO\_LVAR\_INT | 0093  | 1@ =# 0@ |
